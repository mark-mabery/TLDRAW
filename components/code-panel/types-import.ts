/* eslint-disable */

// HEY! DO NOT MODIFY THIS FILE. THE CONTENTS OF THIS FILE
// ARE AUTO-GENERATED BY A SCRIPT AT: /scripts/type-gen.js
// ANY CHANGES WILL BE LOST WHEN THE SCRIPT RUNS AGAIN!

export default {
  name: 'types.ts',
  content: `

type DeepPartial<T> = {
  [P in keyof T]?: DeepPartial<T[P]>;
};



enum ShapeType {
  Dot = 'dot',
  Ellipse = 'ellipse',
  Line = 'line',
  Ray = 'ray',
  Polyline = 'polyline',
  Rectangle = 'rectangle',
  Draw = 'draw',
  Arrow = 'arrow',
  Text = 'text',
  Group = 'group',
}

enum ColorStyle {
  White = 'White',
  LightGray = 'LightGray',
  Gray = 'Gray',
  Black = 'Black',
  Green = 'Green',
  Cyan = 'Cyan',
  Blue = 'Blue',
  Indigo = 'Indigo',
  Violet = 'Violet',
  Red = 'Red',
  Orange = 'Orange',
  Yellow = 'Yellow',
}

enum SizeStyle {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
}

enum DashStyle {
  Solid = 'Solid',
  Dashed = 'Dashed',
  Dotted = 'Dotted',
}

enum FontSize {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  ExtraLarge = 'ExtraLarge',
}

type ShapeStyles = {
  color: ColorStyle
  size: SizeStyle
  dash: DashStyle
  isFilled: boolean
}

interface BaseShape {
  id: string
  type: ShapeType
  parentId: string
  childIndex: number
  isGenerated: boolean
  name: string
  point: number[]
  style: ShapeStyles
  rotation: number
  children?: string[]
  bindings?: Record<string, ShapeBinding>
  handles?: Record<string, ShapeHandle>
  isLocked: boolean
  isHidden: boolean
  isAspectRatioLocked: boolean
}

interface DotShape extends BaseShape {
  type: ShapeType.Dot
}

interface EllipseShape extends BaseShape {
  type: ShapeType.Ellipse
  radiusX: number
  radiusY: number
}

interface LineShape extends BaseShape {
  type: ShapeType.Line
  direction: number[]
}

interface RayShape extends BaseShape {
  type: ShapeType.Ray
  direction: number[]
}

interface PolylineShape extends BaseShape {
  type: ShapeType.Polyline
  points: number[][]
}

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

interface ArrowShape extends BaseShape {
  type: ShapeType.Arrow
  handles: Record<string, ShapeHandle>
  bend: number
  decorations?: {
    start: Decoration
    end: Decoration
    middle: Decoration
  }
}

interface TextShape extends BaseShape {
  type: ShapeType.Text
  text: string
  scale: number
}

interface GroupShape extends BaseShape {
  type: ShapeType.Group
  children: string[]
  size: number[]
}

// type DeepPartial<T> = {
//   [P in keyof T]?: DeepPartial<T[P]>
// }

type ShapeProps<T extends Shape> = {
  [P in keyof T]?: P extends 'style' ? Partial<T[P]> : T[P]
}

type MutableShape =
  | DotShape
  | EllipseShape
  | LineShape
  | RayShape
  | PolylineShape
  | DrawShape
  | RectangleShape
  | ArrowShape
  | TextShape
  | GroupShape

interface Shapes {
  [ShapeType.Dot]: Readonly<DotShape>
  [ShapeType.Ellipse]: Readonly<EllipseShape>
  [ShapeType.Line]: Readonly<LineShape>
  [ShapeType.Ray]: Readonly<RayShape>
  [ShapeType.Polyline]: Readonly<PolylineShape>
  [ShapeType.Draw]: Readonly<DrawShape>
  [ShapeType.Rectangle]: Readonly<RectangleShape>
  [ShapeType.Arrow]: Readonly<ArrowShape>
  [ShapeType.Text]: Readonly<TextShape>
  [ShapeType.Group]: Readonly<GroupShape>
}

type Shape = Readonly<MutableShape>

type ShapeByType<T extends ShapeType> = Shapes[T]

enum Decoration {
  Arrow = 'Arrow',
}

interface ShapeBinding {
  id: string
  index: number
  point: number[]
}

interface ShapeHandle {
  id: string
  index: number
  point: number[]
}

interface CodeFile {
  id: string
  name: string
  code: string
}

interface CodeError {
  message: string
  line: number
  column: number
}

interface CodeResult {
  shapes: Shape[]
  controls: CodeControl[]
  error: CodeError
}

/* -------------------------------------------------- */
/*                      Editor UI                     */
/* -------------------------------------------------- */

interface PointerInfo {
  target: string
  pointerId: number
  origin: number[]
  point: number[]
  pressure: number
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

enum Edge {
  Top = 'top_edge',
  Right = 'right_edge',
  Bottom = 'bottom_edge',
  Left = 'left_edge',
}

enum Corner {
  TopLeft = 'top_left_corner',
  TopRight = 'top_right_corner',
  BottomRight = 'bottom_right_corner',
  BottomLeft = 'bottom_left_corner',
}

interface Bounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
  rotation?: number
}

interface RotatedBounds extends Bounds {
  rotation: number
}

interface ShapeBounds extends Bounds {
  id: string
}

interface PointSnapshot extends Bounds {
  nx: number
  nmx: number
  ny: number
  nmy: number
}

interface BoundsSnapshot extends PointSnapshot {
  nw: number
  nh: number
}

type Difference<A, B> = A extends B ? never : A

type ShapeSpecificProps<T extends Shape> = Pick<
  T,
  Difference<keyof T, keyof BaseShape>
>

type ShapeIndicatorProps<T extends Shape> = ShapeSpecificProps<T>

type ShapeUtil<K extends Shape> = {
  create(props: Partial<K>): K
  getBounds(shape: K): Bounds
  hitTest(shape: K, test: number[]): boolean
  hitTestBounds(shape: K, bounds: Bounds): boolean
  rotate(shape: K): K
  translate(shape: K, delta: number[]): K
  scale(shape: K, scale: number): K
  stretch(shape: K, scaleX: number, scaleY: number): K
  render(shape: K): JSX.Element
}

enum MoveType {
  Backward,
  Forward,
  ToFront,
  ToBack,
}

enum AlignType {
  Top,
  CenterVertical,
  Bottom,
  Left,
  CenterHorizontal,
  Right,
}

enum StretchType {
  Horizontal,
  Vertical,
}

enum DistributeType {
  Horizontal,
  Vertical,
}

interface BezierCurveSegment {
  start: number[]
  tangentStart: number[]
  normalStart: number[]
  pressureStart: number
  end: number[]
  tangentEnd: number[]
  normalEnd: number[]
  pressureEnd: number
}

/* -------------------------------------------------- */
/*                     Code Editor                    */
/* -------------------------------------------------- */

enum ControlType {
  Number = 'number',
  Vector = 'vector',
  Text = 'text',
  Select = 'select',
}

interface BaseCodeControl {
  id: string
  type: ControlType
  label: string
}

interface NumberCodeControl extends BaseCodeControl {
  type: ControlType.Number
  value: number
  min?: number
  max?: number
  step?: number
  format?: (value: number) => number
}

interface VectorCodeControl extends BaseCodeControl {
  type: ControlType.Vector
  value: number[]
  min?: number
  max?: number
  step?: number
  isNormalized?: boolean
  format?: (value: number[]) => number[]
}

interface TextCodeControl extends BaseCodeControl {
  type: ControlType.Text
  value: string
  format?: (value: string) => string
}

interface SelectCodeControl<T extends string = ''>
  extends BaseCodeControl {
  type: ControlType.Select
  value: T
  options: T[]
  format?: (string: T) => string
}

type CodeControl =
  | NumberCodeControl
  | VectorCodeControl
  | TextCodeControl

type PropsOfType<T extends Record<string, unknown>> = {
  [K in keyof T]: T[K] extends boolean ? K : never
}[keyof T]

type Mutable<T extends Shape> = { -readonly [K in keyof T]: T[K] }

interface ShapeUtility<K extends Shape> {
  // A cache for the computed bounds of this kind of shape.
  boundsCache: WeakMap<K, Bounds>

  // Whether to show transform controls when this shape is selected.
  canTransform: boolean

  // Whether the shape's aspect ratio can change.
  canChangeAspectRatio: boolean

  // Whether the shape's style can be filled.
  canStyleFill: boolean

  // Whether the shape may be edited in an editing mode
  canEdit: boolean

  // Whether the shape is a foreign object.
  isForeignObject: boolean

  // Whether the shape can contain other shapes.
  isParent: boolean

  // Whether the shape is only shown when on hovered.
  isShy: boolean

  // Create a new shape.
  create(props: Partial<K>): K

  // Update a shape's styles
  applyStyles(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    style: Partial<ShapeStyles>
  ): ShapeUtility<K>

  translateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  translateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  rotateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number
  ): ShapeUtility<K>

  rotateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number,
    delta: number
  ): ShapeUtility<K>

  // Transform to fit a new bounding box when more than one shape is selected.
  transform(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  // Transform a single shape to fit a new bounding box.
  transformSingle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  setProperty<P extends keyof K>(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    prop: P,
    value: K[P]
  ): ShapeUtility<K>

  // Respond when any child of this shape changes.
  onChildrenChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    children: Shape[]
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's bound elements.
  onBindingChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bindings: Record<string, ShapeBinding>
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's handles.
  onHandleChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: Partial<K['handles']>
  ): ShapeUtility<K>

  onDoublePointHandle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: keyof K['handles'],
    info: PointerInfo
  ): ShapeUtility<K>

  // Respond when a user double clicks the shape's bounds.
  onBoundsReset(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Respond when a user double clicks the center of the shape.
  onDoubleFocus(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Clean up changes when a session ends.
  onSessionComplete(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Render a shape to JSX.
  render(
    this: ShapeUtility<K>,
    shape: K,
    info: {
      isEditing: boolean
      ref?: React.MutableRefObject<HTMLTextAreaElement>
    }
  ): JSX.Element

  invalidate(this: ShapeUtility<K>, shape: K): ShapeUtility<K>

  // Get the bounds of the a shape.
  getBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the routated bounds of the a shape.
  getRotatedBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the center of the shape
  getCenter(this: ShapeUtility<K>, shape: K): number[]

  // Test whether a point lies within a shape.
  hitTest(this: ShapeUtility<K>, shape: K, test: number[]): boolean

  // Test whether bounds collide with or contain a shape.
  hitTestBounds(this: ShapeUtility<K>, shape: K, bounds: Bounds): boolean

  // Get whether the shape should delete
  shouldDelete(this: ShapeUtility<K>, shape: K): boolean

  // Get whether the shape should render
  shouldRender(this: ShapeUtility<K>, shape: K, previous: K): boolean
}




enum ShapeType {
  Dot = 'dot',
  Ellipse = 'ellipse',
  Line = 'line',
  Ray = 'ray',
  Polyline = 'polyline',
  Rectangle = 'rectangle',
  Draw = 'draw',
  Arrow = 'arrow',
  Text = 'text',
  Group = 'group',
}

enum ColorStyle {
  White = 'White',
  LightGray = 'LightGray',
  Gray = 'Gray',
  Black = 'Black',
  Green = 'Green',
  Cyan = 'Cyan',
  Blue = 'Blue',
  Indigo = 'Indigo',
  Violet = 'Violet',
  Red = 'Red',
  Orange = 'Orange',
  Yellow = 'Yellow',
}

enum SizeStyle {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
}

enum DashStyle {
  Solid = 'Solid',
  Dashed = 'Dashed',
  Dotted = 'Dotted',
}

enum FontSize {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  ExtraLarge = 'ExtraLarge',
}

type ShapeStyles = {
  color: ColorStyle
  size: SizeStyle
  dash: DashStyle
  isFilled: boolean
}

interface BaseShape {
  id: string
  type: ShapeType
  parentId: string
  childIndex: number
  isGenerated: boolean
  name: string
  point: number[]
  style: ShapeStyles
  rotation: number
  children?: string[]
  bindings?: Record<string, ShapeBinding>
  handles?: Record<string, ShapeHandle>
  isLocked: boolean
  isHidden: boolean
  isAspectRatioLocked: boolean
}

interface DotShape extends BaseShape {
  type: ShapeType.Dot
}

interface EllipseShape extends BaseShape {
  type: ShapeType.Ellipse
  radiusX: number
  radiusY: number
}

interface LineShape extends BaseShape {
  type: ShapeType.Line
  direction: number[]
}

interface RayShape extends BaseShape {
  type: ShapeType.Ray
  direction: number[]
}

interface PolylineShape extends BaseShape {
  type: ShapeType.Polyline
  points: number[][]
}

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

interface ArrowShape extends BaseShape {
  type: ShapeType.Arrow
  handles: Record<string, ShapeHandle>
  bend: number
  decorations?: {
    start: Decoration
    end: Decoration
    middle: Decoration
  }
}

interface TextShape extends BaseShape {
  type: ShapeType.Text
  text: string
  scale: number
}

interface GroupShape extends BaseShape {
  type: ShapeType.Group
  children: string[]
  size: number[]
}

// type DeepPartial<T> = {
//   [P in keyof T]?: DeepPartial<T[P]>
// }

type ShapeProps<T extends Shape> = {
  [P in keyof T]?: P extends 'style' ? Partial<T[P]> : T[P]
}

type MutableShape =
  | DotShape
  | EllipseShape
  | LineShape
  | RayShape
  | PolylineShape
  | DrawShape
  | RectangleShape
  | ArrowShape
  | TextShape
  | GroupShape

interface Shapes {
  [ShapeType.Dot]: Readonly<DotShape>
  [ShapeType.Ellipse]: Readonly<EllipseShape>
  [ShapeType.Line]: Readonly<LineShape>
  [ShapeType.Ray]: Readonly<RayShape>
  [ShapeType.Polyline]: Readonly<PolylineShape>
  [ShapeType.Draw]: Readonly<DrawShape>
  [ShapeType.Rectangle]: Readonly<RectangleShape>
  [ShapeType.Arrow]: Readonly<ArrowShape>
  [ShapeType.Text]: Readonly<TextShape>
  [ShapeType.Group]: Readonly<GroupShape>
}

type Shape = Readonly<MutableShape>

type ShapeByType<T extends ShapeType> = Shapes[T]

enum Decoration {
  Arrow = 'Arrow',
}

interface ShapeBinding {
  id: string
  index: number
  point: number[]
}

interface ShapeHandle {
  id: string
  index: number
  point: number[]
}

interface CodeFile {
  id: string
  name: string
  code: string
}

interface CodeError {
  message: string
  line: number
  column: number
}

interface CodeResult {
  shapes: Shape[]
  controls: CodeControl[]
  error: CodeError
}

/* -------------------------------------------------- */
/*                      Editor UI                     */
/* -------------------------------------------------- */

interface PointerInfo {
  target: string
  pointerId: number
  origin: number[]
  point: number[]
  pressure: number
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

enum Edge {
  Top = 'top_edge',
  Right = 'right_edge',
  Bottom = 'bottom_edge',
  Left = 'left_edge',
}

enum Corner {
  TopLeft = 'top_left_corner',
  TopRight = 'top_right_corner',
  BottomRight = 'bottom_right_corner',
  BottomLeft = 'bottom_left_corner',
}

interface Bounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
  rotation?: number
}

interface RotatedBounds extends Bounds {
  rotation: number
}

interface ShapeBounds extends Bounds {
  id: string
}

interface PointSnapshot extends Bounds {
  nx: number
  nmx: number
  ny: number
  nmy: number
}

interface BoundsSnapshot extends PointSnapshot {
  nw: number
  nh: number
}

type Difference<A, B> = A extends B ? never : A

type ShapeSpecificProps<T extends Shape> = Pick<
  T,
  Difference<keyof T, keyof BaseShape>
>

type ShapeIndicatorProps<T extends Shape> = ShapeSpecificProps<T>

type ShapeUtil<K extends Shape> = {
  create(props: Partial<K>): K
  getBounds(shape: K): Bounds
  hitTest(shape: K, test: number[]): boolean
  hitTestBounds(shape: K, bounds: Bounds): boolean
  rotate(shape: K): K
  translate(shape: K, delta: number[]): K
  scale(shape: K, scale: number): K
  stretch(shape: K, scaleX: number, scaleY: number): K
  render(shape: K): JSX.Element
}

enum MoveType {
  Backward,
  Forward,
  ToFront,
  ToBack,
}

enum AlignType {
  Top,
  CenterVertical,
  Bottom,
  Left,
  CenterHorizontal,
  Right,
}

enum StretchType {
  Horizontal,
  Vertical,
}

enum DistributeType {
  Horizontal,
  Vertical,
}

interface BezierCurveSegment {
  start: number[]
  tangentStart: number[]
  normalStart: number[]
  pressureStart: number
  end: number[]
  tangentEnd: number[]
  normalEnd: number[]
  pressureEnd: number
}

/* -------------------------------------------------- */
/*                     Code Editor                    */
/* -------------------------------------------------- */

enum ControlType {
  Number = 'number',
  Vector = 'vector',
  Text = 'text',
  Select = 'select',
}

interface BaseCodeControl {
  id: string
  type: ControlType
  label: string
}

interface NumberCodeControl extends BaseCodeControl {
  type: ControlType.Number
  value: number
  min?: number
  max?: number
  step?: number
  format?: (value: number) => number
}

interface VectorCodeControl extends BaseCodeControl {
  type: ControlType.Vector
  value: number[]
  min?: number
  max?: number
  step?: number
  isNormalized?: boolean
  format?: (value: number[]) => number[]
}

interface TextCodeControl extends BaseCodeControl {
  type: ControlType.Text
  value: string
  format?: (value: string) => string
}

interface SelectCodeControl<T extends string = ''>
  extends BaseCodeControl {
  type: ControlType.Select
  value: T
  options: T[]
  format?: (string: T) => string
}

type CodeControl =
  | NumberCodeControl
  | VectorCodeControl
  | TextCodeControl

type PropsOfType<T extends Record<string, unknown>> = {
  [K in keyof T]: T[K] extends boolean ? K : never
}[keyof T]

type Mutable<T extends Shape> = { -readonly [K in keyof T]: T[K] }

interface ShapeUtility<K extends Shape> {
  // A cache for the computed bounds of this kind of shape.
  boundsCache: WeakMap<K, Bounds>

  // Whether to show transform controls when this shape is selected.
  canTransform: boolean

  // Whether the shape's aspect ratio can change.
  canChangeAspectRatio: boolean

  // Whether the shape's style can be filled.
  canStyleFill: boolean

  // Whether the shape may be edited in an editing mode
  canEdit: boolean

  // Whether the shape is a foreign object.
  isForeignObject: boolean

  // Whether the shape can contain other shapes.
  isParent: boolean

  // Whether the shape is only shown when on hovered.
  isShy: boolean

  // Create a new shape.
  create(props: Partial<K>): K

  // Update a shape's styles
  applyStyles(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    style: Partial<ShapeStyles>
  ): ShapeUtility<K>

  translateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  translateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  rotateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number
  ): ShapeUtility<K>

  rotateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number,
    delta: number
  ): ShapeUtility<K>

  // Transform to fit a new bounding box when more than one shape is selected.
  transform(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  // Transform a single shape to fit a new bounding box.
  transformSingle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  setProperty<P extends keyof K>(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    prop: P,
    value: K[P]
  ): ShapeUtility<K>

  // Respond when any child of this shape changes.
  onChildrenChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    children: Shape[]
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's bound elements.
  onBindingChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bindings: Record<string, ShapeBinding>
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's handles.
  onHandleChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: Partial<K['handles']>
  ): ShapeUtility<K>

  onDoublePointHandle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: keyof K['handles'],
    info: PointerInfo
  ): ShapeUtility<K>

  // Respond when a user double clicks the shape's bounds.
  onBoundsReset(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Respond when a user double clicks the center of the shape.
  onDoubleFocus(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Clean up changes when a session ends.
  onSessionComplete(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Render a shape to JSX.
  render(
    this: ShapeUtility<K>,
    shape: K,
    info: {
      isEditing: boolean
      ref?: React.MutableRefObject<HTMLTextAreaElement>
    }
  ): JSX.Element

  invalidate(this: ShapeUtility<K>, shape: K): ShapeUtility<K>

  // Get the bounds of the a shape.
  getBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the routated bounds of the a shape.
  getRotatedBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the center of the shape
  getCenter(this: ShapeUtility<K>, shape: K): number[]

  // Test whether a point lies within a shape.
  hitTest(this: ShapeUtility<K>, shape: K, test: number[]): boolean

  // Test whether bounds collide with or contain a shape.
  hitTestBounds(this: ShapeUtility<K>, shape: K, bounds: Bounds): boolean

  // Get whether the shape should delete
  shouldDelete(this: ShapeUtility<K>, shape: K): boolean

  // Get whether the shape should render
  shouldRender(this: ShapeUtility<K>, shape: K, previous: K): boolean
}




 class Vec {
  /**
   * Clamp a value into a range.
   * @param n
   * @param min
   */
  static clamp(n: number, min: number): number
  static clamp(n: number, min: number, max: number): number
  static clamp(n: number, min: number, max?: number): number {
    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)
  }

  /**
   * Negate a vector.
   * @param A
   */
  static neg = (A: number[]): number[] => {
    return [-A[0], -A[1]]
  }

  /**
   * Add vectors.
   * @param A
   * @param B
   */
  static add = (A: number[], B: number[]): number[] => {
    return [A[0] + B[0], A[1] + B[1]]
  }

  /**
   * Add scalar to vector.
   * @param A
   * @param B
   */
  static addScalar = (A: number[], n: number): number[] => {
    return [A[0] + n, A[1] + n]
  }

  /**
   * Subtract vectors.
   * @param A
   * @param B
   */
  static sub = (A: number[], B: number[]): number[] => {
    return [A[0] - B[0], A[1] - B[1]]
  }

  /**
   * Subtract scalar from vector.
   * @param A
   * @param B
   */
  static subScalar = (A: number[], n: number): number[] => {
    return [A[0] - n, A[1] - n]
  }

  /**
   * Get the vector from vectors A to B.
   * @param A
   * @param B
   */
  static vec = (A: number[], B: number[]): number[] => {
    // A, B as vectors get the vector from A to B
    return [B[0] - A[0], B[1] - A[1]]
  }

  /**
   * Vector multiplication by scalar
   * @param A
   * @param n
   */
  static mul = (A: number[], n: number): number[] => {
    return [A[0] * n, A[1] * n]
  }

  static mulV = (A: number[], B: number[]): number[] => {
    return [A[0] * B[0], A[1] * B[1]]
  }

  /**
   * Vector division by scalar.
   * @param A
   * @param n
   */
  static div = (A: number[], n: number): number[] => {
    return [A[0] / n, A[1] / n]
  }

  /**
   * Vector division by vector.
   * @param A
   * @param n
   */
  static divV = (A: number[], B: number[]): number[] => {
    return [A[0] / B[0], A[1] / B[1]]
  }

  /**
   * Perpendicular rotation of a vector A
   * @param A
   */
  static per = (A: number[]): number[] => {
    return [A[1], -A[0]]
  }

  /**
   * Dot product
   * @param A
   * @param B
   */
  static dpr = (A: number[], B: number[]): number => {
    return A[0] * B[0] + A[1] * B[1]
  }

  /**
   * Cross product (outer product) | A X B |
   * @param A
   * @param B
   */
  static cpr = (A: number[], B: number[]): number => {
    return A[0] * B[1] - B[0] * A[1]
  }

  /**
   * Length of the vector squared
   * @param A
   */
  static len2 = (A: number[]): number => {
    return A[0] * A[0] + A[1] * A[1]
  }

  /**
   * Length of the vector
   * @param A
   */
  static len = (A: number[]): number => {
    return Math.hypot(A[0], A[1])
  }

  /**
   * Project A over B
   * @param A
   * @param B
   */
  static pry = (A: number[], B: number[]): number => {
    return Vec.dpr(A, B) / Vec.len(B)
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static uni = (A: number[]): number[] => {
    return Vec.div(A, Vec.len(A))
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static normalize = (A: number[]): number[] => {
    return Vec.uni(A)
  }

  /**
   * Get the tangent between two vectors.
   * @param A
   * @param B
   * @returns
   */
  static tangent = (A: number[], B: number[]): number[] => {
    return Vec.normalize(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B squared.
   * @param A
   * @param B
   */
  static dist2 = (A: number[], B: number[]): number => {
    return Vec.len2(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B
   * @param A
   * @param B
   */
  static dist = (A: number[], B: number[]): number => {
    return Math.hypot(A[1] - B[1], A[0] - B[0])
  }

  /**
   * A faster, though less accurate method for testing distances. Maybe faster?
   * @param A
   * @param B
   * @returns
   */
  static fastDist = (A: number[], B: number[]): number[] => {
    const V = [B[0] - A[0], B[1] - A[1]]
    const aV = [Math.abs(V[0]), Math.abs(V[1])]
    let r = 1 / Math.max(aV[0], aV[1])
    r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289)
    return [V[0] * r, V[1] * r]
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static ang = (A: number[], B: number[]): number => {
    return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B))
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static angle = (A: number[], B: number[]): number => {
    return Math.atan2(B[1] - A[1], B[0] - A[0])
  }

  /**
   * Mean between two vectors or mid vector between two vectors
   * @param A
   * @param B
   */
  static med = (A: number[], B: number[]): number[] => {
    return Vec.mul(Vec.add(A, B), 0.5)
  }

  /**
   * Vector rotation by r (radians)
   * @param A
   * @param r rotation in radians
   */
  static rot = (A: number[], r: number): number[] => {
    return [
      A[0] * Math.cos(r) - A[1] * Math.sin(r),
      A[0] * Math.sin(r) + A[1] * Math.cos(r),
    ]
  }

  /**
   * Rotate a vector around another vector by r (radians)
   * @param A vector
   * @param C center
   * @param r rotation in radians
   */
  static rotWith = (A: number[], C: number[], r: number): number[] => {
    if (r === 0) return A

    const s = Math.sin(r)
    const c = Math.cos(r)

    const px = A[0] - C[0]
    const py = A[1] - C[1]

    const nx = px * c - py * s
    const ny = px * s + py * c

    return [nx + C[0], ny + C[1]]
  }

  /**
   * Check of two vectors are identical.
   * @param A
   * @param B
   */
  static isEqual = (A: number[], B: number[]): boolean => {
    return A[0] === B[0] && A[1] === B[1]
  }

  /**
   * Interpolate vector A to B with a scalar t
   * @param A
   * @param B
   * @param t scalar
   */
  static lrp = (A: number[], B: number[], t: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.vec(A, B), t))
  }

  /**
   * Interpolate from A to B when curVAL goes fromVAL: number[] => to
   * @param A
   * @param B
   * @param from Starting value
   * @param to Ending value
   * @param s Strength
   */
  static int = (
    A: number[],
    B: number[],
    from: number,
    to: number,
    s = 1
  ): number[] => {
    const t = (Vec.clamp(from, to) - from) / (to - from)
    return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s))
  }

  /**
   * Get the angle between the three vectors A, B, and C.
   * @param p1
   * @param pc
   * @param p2
   */
  static ang3 = (p1: number[], pc: number[], p2: number[]): number => {
    // this,
    const v1 = Vec.vec(pc, p1)
    const v2 = Vec.vec(pc, p2)
    return Vec.ang(v1, v2)
  }

  /**
   * Absolute value of a vector.
   * @param A
   * @returns
   */
  static abs = (A: number[]): number[] => {
    return [Math.abs(A[0]), Math.abs(A[1])]
  }

  static rescale = (a: number[], n: number): number[] => {
    const l = Vec.len(a)
    return [(n * a[0]) / l, (n * a[1]) / l]
  }

  /**
   * Get whether p1 is left of p2, relative to pc.
   * @param p1
   * @param pc
   * @param p2
   */
  static isLeft = (p1: number[], pc: number[], p2: number[]): number => {
    //  isLeft: >0 for counterclockwise
    //          =0 for none (degenerate)
    //          <0 for clockwise
    return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1])
  }

  static clockwise = (p1: number[], pc: number[], p2: number[]): boolean => {
    return Vec.isLeft(p1, pc, p2) > 0
  }

  static round = (a: number[], d = 5): number[] => {
    return a.map((v) => Number(v.toPrecision(d)))
  }

  /**
   * Get the minimum distance from a point P to a line with a segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @returns
   */
  // static distanceToLine(A: number[], B: number[], P: number[]) {
  //   const delta = sub(B, A)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)
  //   return dir[1]
  // }

  /**
   * Get the nearest point on a line segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @param clamp Whether to clamp the resulting point to the segment.
   * @returns
   */
  // static nearestPointOnLine(
  //   A: number[],
  //   B: number[],
  //   P: number[],
  //   clamp = true
  // ) {
  //   const delta = sub(B, A)
  //   const length = len(delta)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)

  //   if (clamp) {
  //     if (dir[0] < 0) return A
  //     if (dir[0] > length) return B
  //   }

  //   return add(A, div(mul(delta, dir[0]), length))
  // }

  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static nearestPointOnLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number[] => {
    return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))
  }

  /**
   * Distance between a point and a line with a known unit vector that passes through a point.
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static distanceToLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P))
  }

  /**
   * Get the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static nearestPointOnLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number[] => {
    const delta = Vec.sub(B, A)
    const length = Vec.len(delta)
    const u = Vec.div(delta, length)

    const pt = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))

    if (clamp) {
      const da = Vec.dist(A, pt)
      const db = Vec.dist(B, pt)

      if (db < da && da > length) return B
      if (da < db && db > length) return A
    }

    return pt
  }

  /**
   * Distance between a point and the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static distanceToLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp))
  }

  /**
   * Push a point A towards point B by a given distance.
   * @param A
   * @param B
   * @param d
   * @returns
   */
  static nudge = (A: number[], B: number[], d: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.uni(Vec.vec(A, B)), d))
  }

  /**
   * Push a point in a given angle by a given distance.
   * @param A
   * @param B
   * @param d
   */
  static nudgeAtAngle = (A: number[], a: number, d: number): number[] => {
    return [Math.cos(a) * d + A[0], Math.sin(a) * d + A[1]]
  }

  /**
   * Round a vector to a precision length.
   * @param a
   * @param n
   */
  static toPrecision = (a: number[], n = 4): number[] => {
    return [+a[0].toPrecision(n), +a[1].toPrecision(n)]
  }

  /**
   * Get a number of points between two points.
   * @param a
   * @param b
   * @param steps
   */
  static pointsBetween = (a: number[], b: number[], steps = 6): number[][] => {
    return Array.from(Array(steps))
      .map((_, i) => {
        const t = i / steps
        return t * t * t
      })
      .map((t) => [...Vec.lrp(a, b, t), (1 - t) / 2])
  }
}




 class Utils {
  /**
   * Linear interpolation betwen two numbers.
   * @param y1
   * @param y2
   * @param mu
   */
  static lerp(y1: number, y2: number, mu: number): number {
    mu = Utils.clamp(mu, 0, 1)
    return y1 * (1 - mu) + y2 * mu
  }

  /**
   * Modulate a value between two ranges.
   * @param value
   * @param rangeA from [low, high]
   * @param rangeB to [low, high]
   * @param clamp
   */
  static modulate(
    value: number,
    rangeA: number[],
    rangeB: number[],
    clamp = false
  ): number {
    const [fromLow, fromHigh] = rangeA
    const [v0, v1] = rangeB
    const result = v0 + ((value - fromLow) / (fromHigh - fromLow)) * (v1 - v0)

    return clamp
      ? v0 < v1
        ? Math.max(Math.min(result, v1), v0)
        : Math.max(Math.min(result, v0), v1)
      : result
  }

  /**
   * Clamp a value into a range.
   * @param n
   * @param min
   */
  static clamp(n: number, min: number): number
  static clamp(n: number, min: number, max: number): number
  static clamp(n: number, min: number, max?: number): number {
    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)
  }

  // TODO: replace with a string compression algorithm
  static compress(s: string): string {
    return s
  }

  // TODO: replace with a string decompression algorithm
  static decompress(s: string): string {
    return s
  }

  /**
   * Recursively clone an object or array.
   * @param obj
   */
  static deepClone<T>(obj: T): T {
    if (obj === null) return null

    const clone: any = { ...obj }

    Object.keys(obj).forEach(
      (key) =>
        (clone[key] =
          typeof obj[key] === 'object' ? Utils.deepClone(obj[key]) : obj[key])
    )

    if (Array.isArray(obj)) {
      clone.length = obj.length
      return Array.from(clone) as any as T
    }

    return clone as T
  }

  /**
   * Seeded random number generator, using [xorshift](https://en.wikipedia.org/wiki/Xorshift).
   * The result will always be betweeen -1 and 1.
   *
   * Adapted from [seedrandom](https://github.com/davidbau/seedrandom).
   */
  static rng(seed = ''): () => number {
    let x = 0
    let y = 0
    let z = 0
    let w = 0

    function next() {
      const t = x ^ (x << 11)
      ;(x = y), (y = z), (z = w)
      w ^= ((w >>> 19) ^ t ^ (t >>> 8)) >>> 0
      return w / 0x100000000
    }

    for (let k = 0; k < seed.length + 64; k++) {
      ;(x ^= seed.charCodeAt(k) | 0), next()
    }

    return next
  }

  /**
   * Shuffle the contents of an array.
   * @param arr
   * @param offset
   */
  static shuffleArr<T>(arr: T[], offset: number): T[] {
    return arr.map((_, i) => arr[(i + offset) % arr.length])
  }

  /**
   * Deep compare two arrays.
   * @param a
   * @param b
   */
  static deepCompareArrays<T>(a: T[], b: T[]): boolean {
    if (a?.length !== b?.length) return false
    return Utils.deepCompare(a, b)
  }

  /**
   * Deep compare any values.
   * @param a
   * @param b
   */
  static deepCompare<T>(a: T, b: T): boolean {
    return a === b || JSON.stringify(a) === JSON.stringify(b)
  }

  /**
   * Find whether two arrays intersect.
   * @param a
   * @param b
   * @param fn An optional function to apply to the items of a; will check if b includes the result.
   */
  static arrsIntersect<T, K>(a: T[], b: K[], fn?: (item: K) => T): boolean
  static arrsIntersect<T>(a: T[], b: T[]): boolean
  static arrsIntersect<T>(
    a: T[],
    b: unknown[],
    fn?: (item: unknown) => T
  ): boolean {
    return a.some((item) => b.includes(fn ? fn(item) : item))
  }

  /**
   * Get the unique values from an array of strings or numbers.
   * @param items
   */
  static uniqueArray<T extends string | number>(...items: T[]): T[] {
    return Array.from(new Set(items).values())
  }

  /**
   * Convert a set to an array.
   * @param set
   */
  static setToArray<T>(set: Set<T>): T[] {
    return Array.from(set.values())
  }

  /**
   * Get the outer of between a circle and a point.
   * @param C The circle's center.
   * @param r The circle's radius.
   * @param P The point.
   * @param side
   */
  static getCircleTangentToPoint(
    C: number[],
    r: number,
    P: number[],
    side: number
  ): number[] {
    const B = Vec.lrp(C, P, 0.5),
      r1 = Vec.dist(C, B),
      delta = Vec.sub(B, C),
      d = Vec.len(delta)

    if (!(d <= r + r1 && d >= Math.abs(r - r1))) {
      return
    }

    const a = (r * r - r1 * r1 + d * d) / (2.0 * d),
      n = 1 / d,
      p = Vec.add(C, Vec.mul(delta, a * n)),
      h = Math.sqrt(r * r - a * a),
      k = Vec.mul(Vec.per(delta), h * n)

    return side === 0 ? Vec.add(p, k) : Vec.sub(p, k)
  }

  /**
   * Get outer tangents of two circles.
   * @param x0
   * @param y0
   * @param r0
   * @param x1
   * @param y1
   * @param r1
   * @returns [lx0, ly0, lx1, ly1, rx0, ry0, rx1, ry1]
   */
  static getOuterTangentsOfCircles(
    C0: number[],
    r0: number,
    C1: number[],
    r1: number
  ): number[][] {
    const a0 = Vec.angle(C0, C1)
    const d = Vec.dist(C0, C1)

    // Circles are overlapping, no tangents
    if (d < Math.abs(r1 - r0)) return

    const a1 = Math.acos((r0 - r1) / d),
      t0 = a0 + a1,
      t1 = a0 - a1

    return [
      [C0[0] + r0 * Math.cos(t1), C0[1] + r0 * Math.sin(t1)],
      [C1[0] + r1 * Math.cos(t1), C1[1] + r1 * Math.sin(t1)],
      [C0[0] + r0 * Math.cos(t0), C0[1] + r0 * Math.sin(t0)],
      [C1[0] + r1 * Math.cos(t0), C1[1] + r1 * Math.sin(t0)],
    ]
  }

  /**
   * Get the closest point on the perimeter of a circle to a given point.
   * @param C The circle's center.
   * @param r The circle's radius.
   * @param P The point.
   */
  static getClosestPointOnCircle(
    C: number[],
    r: number,
    P: number[]
  ): number[] {
    const v = Vec.sub(C, P)
    return Vec.sub(C, Vec.mul(Vec.div(v, Vec.len(v)), r))
  }

  static det(
    a: number,
    b: number,
    c: number,
    d: number,
    e: number,
    f: number,
    g: number,
    h: number,
    i: number
  ): number {
    return a * e * i + b * f * g + c * d * h - a * f * h - b * d * i - c * e * g
  }

  /**
   * Get a circle from three points.
   * @param A
   * @param B
   * @param C
   * @returns [x, y, r]
   */
  static circleFromThreePoints(
    A: number[],
    B: number[],
    C: number[]
  ): number[] {
    const a = Utils.det(A[0], A[1], 1, B[0], B[1], 1, C[0], C[1], 1)

    const bx = -Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[1],
      1,
      B[0] * B[0] + B[1] * B[1],
      B[1],
      1,
      C[0] * C[0] + C[1] * C[1],
      C[1],
      1
    )
    const by = Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[0],
      1,
      B[0] * B[0] + B[1] * B[1],
      B[0],
      1,
      C[0] * C[0] + C[1] * C[1],
      C[0],
      1
    )
    const c = -Utils.det(
      A[0] * A[0] + A[1] * A[1],
      A[0],
      A[1],
      B[0] * B[0] + B[1] * B[1],
      B[0],
      B[1],
      C[0] * C[0] + C[1] * C[1],
      C[0],
      C[1]
    )

    const x = -bx / (2 * a)
    const y = -by / (2 * a)
    const r = Math.sqrt(bx * bx + by * by - 4 * a * c) / (2 * Math.abs(a))

    return [x, y, r]
  }

  /**
   * Find the approximate perimeter of an ellipse.
   * @param rx
   * @param ry
   */
  static perimeterOfEllipse(rx: number, ry: number): number {
    const h = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2)
    const p = Math.PI * (rx + ry) * (1 + (3 * h) / (10 + Math.sqrt(4 - 3 * h)))
    return p
  }

  /**
   * Get the short angle distance between two angles.
   * @param a0
   * @param a1
   */
  static shortAngleDist(a0: number, a1: number): number {
    const max = Math.PI * 2
    const da = (a1 - a0) % max
    return ((2 * da) % max) - da
  }

  /**
   * Get the long angle distance between two angles.
   * @param a0
   * @param a1
   */
  static longAngleDist(a0: number, a1: number): number {
    return Math.PI * 2 - Utils.shortAngleDist(a0, a1)
  }

  /**
   * Interpolate an angle between two angles.
   * @param a0
   * @param a1
   * @param t
   */
  static lerpAngles(a0: number, a1: number, t: number): number {
    return a0 + Utils.shortAngleDist(a0, a1) * t
  }

  /**
   * Get the short distance between two angles.
   * @param a0
   * @param a1
   */
  static angleDelta(a0: number, a1: number): number {
    return Utils.shortAngleDist(a0, a1)
  }

  /**
   * Get the "sweep" or short distance between two points on a circle's perimeter.
   * @param C
   * @param A
   * @param B
   */
  static getSweep(C: number[], A: number[], B: number[]): number {
    return Utils.angleDelta(Vec.angle(C, A), Vec.angle(C, B))
  }

  /**
   * Rotate a point around a center.
   * @param x The x-axis coordinate of the point.
   * @param y The y-axis coordinate of the point.
   * @param cx The x-axis coordinate of the point to rotate round.
   * @param cy The y-axis coordinate of the point to rotate round.
   * @param angle The distance (in radians) to rotate.
   */
  static rotatePoint(A: number[], B: number[], angle: number): number[] {
    const s = Math.sin(angle)
    const c = Math.cos(angle)

    const px = A[0] - B[0]
    const py = A[1] - B[1]

    const nx = px * c - py * s
    const ny = px * s + py * c

    return [nx + B[0], ny + B[1]]
  }

  /**
   * Clamp radians within 0 and 2PI
   * @param r
   */
  static clampRadians(r: number): number {
    return (Math.PI * 2 + r) % (Math.PI * 2)
  }

  /**
   * Clamp rotation to even segments.
   * @param r
   * @param segments
   */
  static clampToRotationToSegments(r: number, segments: number): number {
    const seg = (Math.PI * 2) / segments
    return Math.floor((Utils.clampRadians(r) + seg / 2) / seg) * seg
  }

  /**
   * Is angle c between angles a and b?
   * @param a
   * @param b
   * @param c
   */
  static isAngleBetween(a: number, b: number, c: number): boolean {
    if (c === a || c === b) return true
    const PI2 = Math.PI * 2
    const AB = (b - a + PI2) % PI2
    const AC = (c - a + PI2) % PI2
    return AB <= Math.PI !== AC > AB
  }

  /**
   * Convert degrees to radians.
   * @param d
   */
  static degreesToRadians(d: number): number {
    return (d * Math.PI) / 180
  }

  /**
   * Convert radians to degrees.
   * @param r
   */
  static radiansToDegrees(r: number): number {
    return (r * 180) / Math.PI
  }

  /**
   * Get the length of an arc between two points on a circle's perimeter.
   * @param C
   * @param r
   * @param A
   * @param B
   */
  static getArcLength(
    C: number[],
    r: number,
    A: number[],
    B: number[]
  ): number {
    const sweep = Utils.getSweep(C, A, B)
    return r * (2 * Math.PI) * (sweep / (2 * Math.PI))
  }

  /**
   * Get a dash offset for an arc, based on its length.
   * @param C
   * @param r
   * @param A
   * @param B
   * @param step
   */
  static getArcDashOffset(
    C: number[],
    r: number,
    A: number[],
    B: number[],
    step: number
  ): number {
    const del0 = Utils.getSweep(C, A, B)
    const len0 = Utils.getArcLength(C, r, A, B)
    const off0 = del0 < 0 ? len0 : 2 * Math.PI * C[2] - len0
    return -off0 / 2 + step
  }

  /**
   * Get a dash offset for an ellipse, based on its length.
   * @param A
   * @param step
   */
  static getEllipseDashOffset(A: number[], step: number): number {
    const c = 2 * Math.PI * A[2]
    return -c / 2 + -step
  }

  /**
   * Get an array of points between two points.
   * @param a
   * @param b
   * @param options
   */
  static getPointsBetween(
    a: number[],
    b: number[],
    options = {} as {
      steps?: number
      ease?: (t: number) => number
    }
  ): number[][] {
    const { steps = 6, ease = (t) => t * t * t } = options

    return Array.from(Array(steps))
      .map((_, i) => ease(i / steps))
      .map((t) => [...Vec.lrp(a, b, t), (1 - t) / 2])
  }

  static getRayRayIntersection(
    p0: number[],
    n0: number[],
    p1: number[],
    n1: number[]
  ): number[] {
    const p0e = Vec.add(p0, n0),
      p1e = Vec.add(p1, n1),
      m0 = (p0e[1] - p0[1]) / (p0e[0] - p0[0]),
      m1 = (p1e[1] - p1[1]) / (p1e[0] - p1[0]),
      b0 = p0[1] - m0 * p0[0],
      b1 = p1[1] - m1 * p1[0],
      x = (b1 - b0) / (m0 - m1),
      y = m0 * x + b0

    return [x, y]
  }

  static bez1d(a: number, b: number, c: number, d: number, t: number): number {
    return (
      a * (1 - t) * (1 - t) * (1 - t) +
      3 * b * t * (1 - t) * (1 - t) +
      3 * c * t * t * (1 - t) +
      d * t * t * t
    )
  }

  static getCubicBezierBounds(
    p0: number[],
    c0: number[],
    c1: number[],
    p1: number[]
  ): Bounds {
    // solve for x
    let a = 3 * p1[0] - 9 * c1[0] + 9 * c0[0] - 3 * p0[0]
    let b = 6 * p0[0] - 12 * c0[0] + 6 * c1[0]
    let c = 3 * c0[0] - 3 * p0[0]
    let disc = b * b - 4 * a * c
    let xl = p0[0]
    let xh = p0[0]

    if (p1[0] < xl) xl = p1[0]
    if (p1[0] > xh) xh = p1[0]

    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const x1 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t1)
        if (x1 < xl) xl = x1
        if (x1 > xh) xh = x1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const x2 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t2)
        if (x2 < xl) xl = x2
        if (x2 > xh) xh = x2
      }
    }

    // Solve for y
    a = 3 * p1[1] - 9 * c1[1] + 9 * c0[1] - 3 * p0[1]
    b = 6 * p0[1] - 12 * c0[1] + 6 * c1[1]
    c = 3 * c0[1] - 3 * p0[1]
    disc = b * b - 4 * a * c
    let yl = p0[1]
    let yh = p0[1]
    if (p1[1] < yl) yl = p1[1]
    if (p1[1] > yh) yh = p1[1]
    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const y1 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t1)
        if (y1 < yl) yl = y1
        if (y1 > yh) yh = y1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const y2 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t2)
        if (y2 < yl) yl = y2
        if (y2 > yh) yh = y2
      }
    }

    return {
      minX: xl,
      minY: yl,
      maxX: xh,
      maxY: yh,
      width: Math.abs(xl - xh),
      height: Math.abs(yl - yh),
    }
  }

  static getExpandedBounds(a: Bounds, b: Bounds): Bounds {
    const minX = Math.min(a.minX, b.minX),
      minY = Math.min(a.minY, b.minY),
      maxX = Math.max(a.maxX, b.maxX),
      maxY = Math.max(a.maxY, b.maxY),
      width = Math.abs(maxX - minX),
      height = Math.abs(maxY - minY)

    return { minX, minY, maxX, maxY, width, height }
  }

  static getCommonBounds(...b: Bounds[]): Bounds {
    if (b.length < 2) return b[0]

    let bounds = b[0]

    for (let i = 1; i < b.length; i++) {
      bounds = Utils.getExpandedBounds(bounds, b[i])
    }

    return bounds
  }

  /**
   * Get a bezier curve data for a spline that fits an array of points.
   * @param pts
   * @param tension
   * @param isClosed
   * @param numOfSegments
   */
  static getCurvePoints(
    pts: number[][],
    tension = 0.5,
    isClosed = false,
    numOfSegments = 3
  ): number[][] {
    const _pts = [...pts],
      len = pts.length,
      res: number[][] = [] // results

    let t1x: number, // tension vectors
      t2x: number,
      t1y: number,
      t2y: number,
      c1: number, // cardinal points
      c2: number,
      c3: number,
      c4: number,
      st: number,
      st2: number,
      st3: number

    // The algorithm require a previous and next point to the actual point array.
    // Check if we will draw closed or open curve.
    // If closed, copy end points to beginning and first points to end
    // If open, duplicate first points to befinning, end points to end
    if (isClosed) {
      _pts.unshift(_pts[len - 1])
      _pts.push(_pts[0])
    } else {
      //copy 1. point and insert at beginning
      _pts.unshift(_pts[0])
      _pts.push(_pts[len - 1])
      // _pts.push(_pts[len - 1])
    }

    // For each point, calculate a segment
    for (let i = 1; i < _pts.length - 2; i++) {
      // Calculate points along segment and add to results
      for (let t = 0; t <= numOfSegments; t++) {
        // Step
        st = t / numOfSegments
        st2 = Math.pow(st, 2)
        st3 = Math.pow(st, 3)

        // Cardinals
        c1 = 2 * st3 - 3 * st2 + 1
        c2 = -(2 * st3) + 3 * st2
        c3 = st3 - 2 * st2 + st
        c4 = st3 - st2

        // Tension
        t1x = (_pts[i + 1][0] - _pts[i - 1][0]) * tension
        t2x = (_pts[i + 2][0] - _pts[i][0]) * tension
        t1y = (_pts[i + 1][1] - _pts[i - 1][1]) * tension
        t2y = (_pts[i + 2][1] - _pts[i][1]) * tension

        // Control points
        res.push([
          c1 * _pts[i][0] + c2 * _pts[i + 1][0] + c3 * t1x + c4 * t2x,
          c1 * _pts[i][1] + c2 * _pts[i + 1][1] + c3 * t1y + c4 * t2y,
        ])
      }
    }

    res.push(pts[pts.length - 1])

    return res
  }

  /**
   * Simplify a line (using Ramer-Douglas-Peucker algorithm).
   * @param points An array of points as [x, y, ...][]
   * @param tolerance The minimum line distance (also called epsilon).
   * @returns Simplified array as [x, y, ...][]
   */
  static simplify(points: number[][], tolerance = 1): number[][] {
    const len = points.length,
      a = points[0],
      b = points[len - 1],
      [x1, y1] = a,
      [x2, y2] = b

    if (len > 2) {
      let distance = 0
      let index = 0
      const max = Math.hypot(y2 - y1, x2 - x1)

      for (let i = 1; i < len - 1; i++) {
        const [x0, y0] = points[i],
          d =
            Math.abs((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) / max

        if (distance > d) continue

        distance = d
        index = i
      }

      if (distance > tolerance) {
        const l0 = Utils.simplify(points.slice(0, index + 1), tolerance)
        const l1 = Utils.simplify(points.slice(index + 1), tolerance)
        return l0.concat(l1.slice(1))
      }
    }

    return [a, b]
  }
}




 class CodeShape<T extends Shape> {
  private _shape: Mutable<T>
  protected utils: ShapeUtility<T>

  constructor(props: T) {
    this._shape = createShape(props.type, props) as Mutable<T>
    this.utils = getShapeUtils<T>(this._shape)
    codeShapes.add(this)
  }

  /**
   * Destroy the shape.
   *
   * \`\`\`ts
   * shape.destroy()
   * \`\`\`
   */
  destroy = (): void => {
    codeShapes.delete(this)
  }

  /**
   * Move the shape to a point.
   *
   * \`\`\`ts
   * shape.moveTo(100,100)
   * \`\`\`
   */
  moveTo = (point: number[]): CodeShape<T> => {
    return this.translateTo(point)
  }

  /**
   * Move the shape to a point.
   *
   * \`\`\`ts
   * shape.translateTo([100,100])
   * \`\`\`
   */
  translateTo = (point: number[]): CodeShape<T> => {
    this.utils.translateTo(this._shape, point)
    return this
  }

  /**
   * Move the shape by a delta.
   *
   * \`\`\`ts
   * shape.translateBy([100,100])
   * \`\`\`
   */
  translateBy = (delta: number[]): CodeShape<T> => {
    this.utils.translateTo(this._shape, delta)
    return this
  }

  /**
   * Rotate the shape.
   *
   * \`\`\`ts
   * shape.rotateTo(Math.PI / 2)
   * \`\`\`
   */
  rotateTo = (rotation: number): CodeShape<T> => {
    this.utils.rotateTo(this._shape, rotation, this.shape.rotation - rotation)
    return this
  }

  /**
   * Rotate the shape by a delta.
   *
   * \`\`\`ts
   * shape.rotateBy(Math.PI / 2)
   * \`\`\`
   */
  rotateBy = (rotation: number): CodeShape<T> => {
    this.utils.rotateBy(this._shape, rotation)
    return this
  }

  /**
   * Get the shape's bounding box.
   *
   * \`\`\`ts
   * const bounds = shape.getBounds()
   * \`\`\`
   */
  getBounds = (): CodeShape<T> => {
    this.utils.getBounds(this.shape)
    return this
  }

  /**
   * Test whether a point is inside of the shape.
   *
   * \`\`\`ts
   * const isHit = shape.hitTest()
   * \`\`\`
   */
  hitTest = (point: number[]): CodeShape<T> => {
    this.utils.hitTest(this.shape, point)
    return this
  }

  /**
   * Duplicate this shape.
   *
   * \`\`\`ts
   * const shapeB = shape.duplicate()
   * \`\`\`
   */
  duplicate = (): CodeShape<T> => {
    const duplicate = Object.assign(
      Object.create(Object.getPrototypeOf(this)),
      this
    )

    duplicate._shape = createShape(this._shape.type, {
      ...this._shape,
      id: uniqueId(),
    } as any)

    codeShapes.add(duplicate)
    return duplicate
  }

  /**
   * Move the shape to the back of the painting order.
   *
   * \`\`\`ts
   * shape.moveToBack()
   * \`\`\`
   */
  moveToBack = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const first = sorted[0].childIndex
    sorted.forEach((shape) => shape.childIndex++)
    this.childIndex = first

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape to the top of the painting order.
   *
   * \`\`\`ts
   * shape.moveToFront()
   * \`\`\`
   */
  moveToFront = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const ahead = sorted.slice(sorted.indexOf(this))
    const last = ahead[ahead.length - 1].childIndex
    ahead.forEach((shape) => shape.childIndex--)
    this.childIndex = last

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape backward in the painting order.
   *
   * \`\`\`ts
   * shape.moveBackward()
   * \`\`\`
   */
  moveBackward = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const next = sorted[sorted.indexOf(this) - 1]

    if (!next) return

    const index = next.childIndex
    next.childIndex = this.childIndex
    this.childIndex = index

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  /**
   * Move the shape forward in the painting order.
   *
   * \`\`\`ts
   * shape.moveForward()
   * \`\`\`
   */
  moveForward = (): CodeShape<T> => {
    const sorted = getOrderedShapes()

    if (sorted.length <= 1) return

    const next = sorted[sorted.indexOf(this) + 1]

    if (!next) return

    const index = next.childIndex
    next.childIndex = this.childIndex
    this.childIndex = index

    codeShapes.clear()
    sorted.forEach((shape) => codeShapes.add(shape))

    return this
  }

  get id(): string {
    return this._shape.id
  }

  /**
   * The shape's underlying shape (readonly).
   *
   * \`\`\`ts
   * const underlyingShape = shape.shape
   * \`\`\`
   */
  get shape(): Readonly<T> {
    return this._shape
  }

  /**
   * The shape's current point.
   *
   * \`\`\`ts
   * const shapePoint = shape.point()
   * \`\`\`
   */
  get point(): number[] {
    return [...this.shape.point]
  }

  set point(point: number[]) {
    this.utils.translateTo(this._shape, point)
  }

  /**
   * The shape's current x position.
   *
   * \`\`\`ts
   * const shapeX = shape.x
   *
   * shape.x = 100
   * \`\`\`
   */
  get x(): number {
    return this.point[0]
  }

  set x(x: number) {
    this.utils.translateTo(this._shape, [x, this.y])
  }

  /**
   * The shape's current y position.
   *
   * \`\`\`ts
   * const shapeY = shape.y
   *
   * shape.y = 100
   * \`\`\`
   */
  get y(): number {
    return this.point[1]
  }

  set y(y: number) {
    this.utils.translateTo(this._shape, [this.x, y])
  }

  /**
   * The shape's rotation.
   *
   * \`\`\`ts
   * const shapeRotation = shape.rotation
   *
   * shape.rotation = Math.PI / 2
   * \`\`\`
   */
  get rotation(): number {
    return this.shape.rotation
  }

  set rotation(rotation: number) {
    this.utils.rotateTo(this._shape, rotation, rotation - this.shape.rotation)
  }

  /**
   * The shape's color style (ColorStyle).
   *
   * \`\`\`ts
   * const shapeColor = shape.color
   *
   * shape.color = ColorStyle.Red
   * \`\`\`
   */
  get color(): ColorStyle {
    return this.shape.style.color
  }

  set color(color: ColorStyle) {
    this.utils.applyStyles(this._shape, { color })
  }

  /**
   * The shape's dash style (DashStyle).
   *
   * \`\`\`ts
   * const shapeDash = shape.dash
   *
   * shape.dash = DashStyle.Dotted
   * \`\`\`
   */
  get dash(): DashStyle {
    return this.shape.style.dash
  }

  set dash(dash: DashStyle) {
    this.utils.applyStyles(this._shape, { dash })
  }

  /**
   * The shape's size (SizeStyle).
   *
   * \`\`\`ts
   * const shapeSize = shape.size
   *
   * shape.size = SizeStyle.Large
   * \`\`\`
   */
  get size(): SizeStyle {
    return this.shape.style.size
  }

  set size(size: SizeStyle) {
    this.utils.applyStyles(this._shape, { size })
  }

  /**
   * The shape's index in the painting order.
   *
   * \`\`\`ts
   * const shapeChildIndex = shape.childIndex
   *
   * shape.childIndex = 10
   * \`\`\`
   */
  get childIndex(): number {
    return this.shape.childIndex
  }

  set childIndex(childIndex: number) {
    this.utils.setProperty(this._shape, 'childIndex', childIndex)
  }

  /**
   * The shape's center.
   *
   * \`\`\`ts
   * const shapeCenter = shape.center
   *
   * shape.center = [100, 100]
   * \`\`\`
   */
  get center(): number[] {
    return this.utils.getCenter(this.shape)
  }

  set center(center: number[]) {
    const oldCenter = this.utils.getCenter(this.shape)
    const delta = Vec.sub(center, oldCenter)
    this.translateBy(delta)
  }
}




 class Dot extends CodeShape<DotShape> {
  constructor(props = {} as ShapeProps<DotShape>) {
    super({
      id: uniqueId(),

      parentId: (window as any).currentPageId,
      type: ShapeType.Dot,
      isGenerated: true,
      name: 'Dot',
      childIndex: 0,
      point: [0, 0],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: true,
      },
    })
  }
}




 class Ellipse extends CodeShape<EllipseShape> {
  constructor(props = {} as ShapeProps<EllipseShape>) {
    super({
      id: uniqueId(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Ellipse,
      isGenerated: true,
      name: 'Ellipse',
      childIndex: 0,
      point: [0, 0],
      radiusX: 50,
      radiusY: 50,
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: { ...defaultStyle, ...props.style },
    })
  }

  /**
   * The ellipse's x radius.
   *
   * \`\`\`ts
   * const shapeRadiusX = shape.radiusX
   *
   * shape.radiusX = 100
   * \`\`\`
   */
  get radiusX(): number {
    return this.shape.radiusX
  }

  set radiusX(radiusX: number) {
    this.utils.setProperty(this.shape, 'radiusX', radiusX)
  }

  /**
   * The ellipse's y radius.
   *
   * \`\`\`ts
   * const shapeRadiusY = shape.radiusY
   *
   * shape.radiusY = 100
   * \`\`\`
   */
  get radiusY(): number {
    return this.shape.radiusY
  }

  set radiusY(radiusY: number) {
    this.utils.setProperty(this.shape, 'radiusY', radiusY)
  }
}




 class Line extends CodeShape<LineShape> {
  constructor(props = {} as ShapeProps<LineShape>) {
    super({
      id: uniqueId(),

      parentId: (window as any).currentPageId,
      type: ShapeType.Line,
      isGenerated: true,
      name: 'Line',
      childIndex: 0,
      point: [0, 0],
      direction: [-0.5, 0.5],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The line's direction.
   *
   * \`\`\`ts
   * const shapeDirection = shape.direction
   *
   * shape.direction = [0,0]
   * \`\`\`
   */
  get direction(): number[] {
    return this.shape.direction
  }
  set direction(direction: number[]) {
    this.utils.setProperty(this.shape, 'direction', direction)
  }
}




 class Polyline extends CodeShape<PolylineShape> {
  constructor(props = {} as ShapeProps<PolylineShape>) {
    super({
      id: uniqueId(),

      parentId: (window as any).currentPageId,
      type: ShapeType.Polyline,
      isGenerated: true,
      name: 'Polyline',
      childIndex: 0,
      point: [0, 0],
      points: [[0, 0]],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * Add a point to the polyline's points.
   *
   * \`\`\`ts
   * shape.addPoint([100,100])
   * \`\`\`
   */
  addPoint(point: number[]): CodeShape<PolylineShape> {
    this.utils.setProperty(this.shape, 'points', [...this.points, point])
    return this
  }

  /**
   * The polyline's points.
   *
   * \`\`\`ts
   * const shapePoints = shape.points
   *
   * shape.points = [[0,0], [100,100], [100,200]]
   * \`\`\`
   */
  get points(): number[][] {
    return this.shape.points
  }

  set points(points: number[][]) {
    this.utils.setProperty(this.shape, 'points', points)
  }
}




 class Ray extends CodeShape<RayShape> {
  constructor(props = {} as ShapeProps<RayShape>) {
    super({
      id: uniqueId(),

      type: ShapeType.Ray,
      isGenerated: true,
      name: 'Ray',
      parentId: 'page1',
      childIndex: 0,
      point: [0, 0],
      direction: [0, 1],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The ray's direction.
   *
   * \`\`\`ts
   * const shapeDirection = shape.direction
   *
   * shape.direction = [0,0]
   * \`\`\`
   */
  get direction(): number[] {
    return this.shape.direction
  }
  set direction(direction: number[]) {
    this.utils.setProperty(this.shape, 'direction', direction)
  }
}




 class Arrow extends CodeShape<ArrowShape> {
  constructor(
    props = {} as ShapeProps<ArrowShape> & { start: number[]; end: number[] }
  ) {
    const { start = [0, 0], end = [0, 0] } = props

    const {
      point = [0, 0],
      handles = {
        start: {
          id: 'start',
          index: 0,
          point: start,
        },
        end: {
          id: 'end',
          index: 1,
          point: end,
        },
        bend: {
          id: 'bend',
          index: 2,
          point: Vec.med(start, end),
        },
      },
    } = props

    super({
      id: uniqueId(),

      type: ShapeType.Arrow,
      isGenerated: false,
      name: 'Arrow',
      parentId: 'page1',
      childIndex: 0,
      point,
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      bend: 0,
      handles,
      decorations: {
        start: null,
        middle: null,
        end: Decoration.Arrow,
      },
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  /**
   * The arrow's start point.
   *
   * \`\`\`ts
   * const startPoint = shape.start
   *
   * shape.start = [100, 100]
   * \`\`\`
   */
  get start(): number[] {
    return this.shape.handles.start.point
  }

  set start(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      start: { ...this.shape.handles.start, point },
    })
  }

  /**
   * The arrow's middle point.
   *
   * \`\`\`ts
   * const middlePoint = shape.middle
   *
   * shape.middle = [100, 100]
   * \`\`\`
   */
  get middle(): number[] {
    return this.shape.handles.bend.point
  }

  set middle(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      bend: { ...this.shape.handles.bend, point },
    })
  }

  /**
   * The arrow's end point.
   *
   * \`\`\`ts
   * const endPoint = shape.end
   *
   * shape.end = [100, 100]
   * \`\`\`
   */
  get end(): number[] {
    return this.shape.handles.end.point
  }

  set end(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      end: { ...this.shape.handles.end, point },
    })
  }

  get bend(): number {
    return this.shape.bend
  }
}




 class Draw extends CodeShape<DrawShape> {
  constructor(props = {} as ShapeProps<DrawShape>) {
    super({
      id: uniqueId(),

      type: ShapeType.Draw,
      isGenerated: false,
      parentId: (window as any).currentPageId,
      name: 'Draw',
      childIndex: 0,
      point: [0, 0],
      points: [],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }
}




 class Text extends CodeShape<TextShape> {
  constructor(props = {} as ShapeProps<TextShape>) {
    super({
      id: uniqueId(),

      parentId: (window as any).currentPageId,
      type: ShapeType.Text,
      isGenerated: true,
      name: 'Text',
      childIndex: 0,
      point: [0, 0],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      text: 'Text',
      scale: 1,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * The text shape's text content.
   *
   * \`\`\`ts
   * const shapeText = shape.text
   *
   * shape.text = "Hello world!"
   * \`\`\`
   */
  get text(): string {
    return this.shape.text
  }

  set text(text: string) {
    getShapeUtils(this.shape).setProperty(this.shape, 'text', text)
  }

  /**
   * The text's scale.
   *
   * \`\`\`ts
   * const shapeScale = shape.scale
   *
   * shape.scale = 2
   * \`\`\`
   */
  get scale(): number {
    return this.shape.scale
  }

  set scale(scale: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'scale', scale)
  }
}




 class Rectangle extends CodeShape<RectangleShape> {
  constructor(props = {} as ShapeProps<RectangleShape>) {
    super({
      id: uniqueId(),

      parentId: (window as any).currentPageId,
      type: ShapeType.Rectangle,
      isGenerated: true,
      name: 'Rectangle',
      childIndex: 0,
      point: [0, 0],
      size: [100, 100],
      rotation: 0,
      radius: 2,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }

  /**
   * The rectangle's width.
   *
   * \`\`\`ts
   * const shapeWidth = shape.width
   *
   * shape.width = 100
   * \`\`\`
   */
  get width(): number {
    return this.shape.size[0]
  }

  set width(width: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'size', [
      width,
      this.height,
    ])
  }

  /**
   * The rectangle's height.
   *
   * \`\`\`ts
   * const shapeHeight = shape.height
   *
   * shape.height = 100
   * \`\`\`
   */
  get height(): number {
    return this.shape.size[1]
  }

  set height(height: number) {
    getShapeUtils(this.shape).setProperty(this.shape, 'size', [
      this.width,
      height,
    ])
  }
}




class Control<T extends CodeControl> {
  _control: T

  constructor(control: T) {
    this._control = { ...control }
    codeControls.add(this._control)

    // Could there be a better way to prevent this?
    // When updating, constructor should just bind to
    // the existing control rather than creating a new one?
    if (!(window as any).isUpdatingCode) {
      controls[this._control.label] = this._control.value
    }
  }

  destroy(): void {
    codeControls.delete(this.control)
    delete controls[this.control.label]
  }

  get control(): T {
    return this._control
  }

  get id(): string {
    return this.control.id
  }

  get value(): T['value'] {
    return this.control.value
  }
}

type ControlProps<T extends CodeControl> = Omit<Partial<T>, 'type'>

class NumberControl extends Control<NumberCodeControl> {
  constructor(options: ControlProps<NumberCodeControl>) {
    const { id = uniqueId(), label = 'Number', value = 0, step = 1 } = options

    super({
      type: ControlType.Number,
      ...options,
      label,
      value,
      step,
      id,
    })
  }
}

class VectorControl extends Control<VectorCodeControl> {
  constructor(options: ControlProps<VectorCodeControl>) {
    const {
      id = uniqueId(),
      label = 'Vector',
      value = [0, 0],
      isNormalized = false,
    } = options

    super({
      type: ControlType.Vector,
      ...options,
      label,
      value,
      isNormalized,
      id,
    })
  }
}

class TextControl extends Control<TextCodeControl> {
  constructor(options: ControlProps<TextCodeControl>) {
    const { id = uniqueId(), label = 'Text', value = 'text' } = options

    super({
      type: ControlType.Text,
      ...options,
      label,
      value,
      id,
    })
  }
}


const codeShapes = new Set<CodeShape<any>>()
const controls: Record<string, any> = {}
const defaultStyle: ShapeStyles = {
  color: ColorStyle.Black,
  size: SizeStyle.Medium,
  isFilled: false,
  dash: DashStyle.Solid,
}
const uniqueId = () => ''
const codeControls = new Set([])

declare function createShape(type: ShapeType, shape: Shape): any
declare function getShapeUtils<T>(shape: T): any
declare function getOrderedShapes(): CodeShape<any>[]

`,
}
