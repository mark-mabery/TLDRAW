// HEY! DO NOT MODIFY THIS FILE. THE CONTENTS OF THIS FILE
// ARE AUTO-GENERATED BY A SCRIPT AT: /scripts/type-gen.js
// ANY CHANGES WILL BE LOST WHEN THE SCRIPT RUNS AGAIN!

export default {
  name: 'types.ts',
  content: `    

/* -------------------------------------------------- */
/*                    Client State                    */
/* -------------------------------------------------- */

interface Data {
  isReadOnly: boolean
  settings: {
    fontSize: number
    isDarkMode: boolean
    isCodeOpen: boolean
    isStyleOpen: boolean
    nudgeDistanceSmall: number
    nudgeDistanceLarge: number
    isToolLocked: boolean
    isPenLocked: boolean
  }
  currentStyle: ShapeStyles
  activeTool: ShapeType | 'select'
  brush?: Bounds
  boundsRotation: number
  pointedId?: string
  hoveredId?: string
  editingId?: string
  currentPageId: string
  currentParentId: string
  currentCodeFileId: string
  codeControls: Record<string, CodeControl>
  document: TLDocument
  pageStates: Record<string, PageState>
}

/* -------------------------------------------------- */
/*                      Document                      */
/* -------------------------------------------------- */

interface TLDocument {
  id: string
  name: string
  pages: Record<string, Page>
  code: Record<string, CodeFile>
}

interface Page {
  id: string
  type: 'page'
  childIndex: number
  name: string
  shapes: Record<string, Shape>
}

interface PageState {
  id: string
  selectedIds: Set<string>
  camera: {
    point: number[]
    zoom: number
  }
}

enum ShapeType {
  Dot = 'dot',
  Ellipse = 'ellipse',
  Line = 'line',
  Ray = 'ray',
  Polyline = 'polyline',
  Rectangle = 'rectangle',
  Draw = 'draw',
  Arrow = 'arrow',
  Text = 'text',
  Group = 'group',
}

enum ColorStyle {
  White = 'White',
  LightGray = 'LightGray',
  Gray = 'Gray',
  Black = 'Black',
  Green = 'Green',
  Cyan = 'Cyan',
  Blue = 'Blue',
  Indigo = 'Indigo',
  Violet = 'Violet',
  Red = 'Red',
  Orange = 'Orange',
  Yellow = 'Yellow',
}

enum SizeStyle {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
}

enum DashStyle {
  Solid = 'Solid',
  Dashed = 'Dashed',
  Dotted = 'Dotted',
}

enum FontSize {
  Small = 'Small',
  Medium = 'Medium',
  Large = 'Large',
  ExtraLarge = 'ExtraLarge',
}

type ShapeStyles = {
  color: ColorStyle
  size: SizeStyle
  dash: DashStyle
  isFilled: boolean
}

interface BaseShape {
  id: string
  seed: number
  type: ShapeType
  parentId: string
  childIndex: number
  isGenerated: boolean
  name: string
  point: number[]
  style: ShapeStyles
  rotation: number
  children?: string[]
  bindings?: Record<string, ShapeBinding>
  handles?: Record<string, ShapeHandle>
  isLocked: boolean
  isHidden: boolean
  isAspectRatioLocked: boolean
}

interface DotShape extends BaseShape {
  type: ShapeType.Dot
}

interface EllipseShape extends BaseShape {
  type: ShapeType.Ellipse
  radiusX: number
  radiusY: number
}

interface LineShape extends BaseShape {
  type: ShapeType.Line
  direction: number[]
}

interface RayShape extends BaseShape {
  type: ShapeType.Ray
  direction: number[]
}

interface PolylineShape extends BaseShape {
  type: ShapeType.Polyline
  points: number[][]
}

interface RectangleShape extends BaseShape {
  type: ShapeType.Rectangle
  size: number[]
  radius: number
}

interface DrawShape extends BaseShape {
  type: ShapeType.Draw
  points: number[][]
}

interface ArrowShape extends BaseShape {
  type: ShapeType.Arrow
  handles: Record<string, ShapeHandle>
  bend: number
  decorations?: {
    start: Decoration
    end: Decoration
    middle: Decoration
  }
}

interface TextShape extends BaseShape {
  type: ShapeType.Text
  text: string
  size: number[] | 'auto'
  scale: number
  fontSize: FontSize
}

interface GroupShape extends BaseShape {
  type: ShapeType.Group
  children: string[]
  size: number[]
}

type DeepPartial<T> = {
  [P in keyof T]?: DeepPartial<T[P]>
}

type ShapeProps<T extends Shape> = DeepPartial<T>

type MutableShape =
  | DotShape
  | EllipseShape
  | LineShape
  | RayShape
  | PolylineShape
  | DrawShape
  | RectangleShape
  | ArrowShape
  | TextShape
  | GroupShape

interface Shapes {
  [ShapeType.Dot]: Readonly<DotShape>
  [ShapeType.Ellipse]: Readonly<EllipseShape>
  [ShapeType.Line]: Readonly<LineShape>
  [ShapeType.Ray]: Readonly<RayShape>
  [ShapeType.Polyline]: Readonly<PolylineShape>
  [ShapeType.Draw]: Readonly<DrawShape>
  [ShapeType.Rectangle]: Readonly<RectangleShape>
  [ShapeType.Arrow]: Readonly<ArrowShape>
  [ShapeType.Text]: Readonly<TextShape>
  [ShapeType.Group]: Readonly<GroupShape>
}

type Shape = Readonly<MutableShape>

type ShapeByType<T extends ShapeType> = Shapes[T]

interface CodeFile {
  id: string
  name: string
  code: string
}

enum Decoration {
  Arrow = 'Arrow',
}

interface ShapeBinding {
  id: string
  index: number
  point: number[]
}

interface ShapeHandle {
  id: string
  index: number
  point: number[]
}

/* -------------------------------------------------- */
/*                      Editor UI                     */
/* -------------------------------------------------- */

interface PointerInfo {
  target: string
  pointerId: number
  origin: number[]
  point: number[]
  pressure: number
  shiftKey: boolean
  ctrlKey: boolean
  metaKey: boolean
  altKey: boolean
}

enum Edge {
  Top = 'top_edge',
  Right = 'right_edge',
  Bottom = 'bottom_edge',
  Left = 'left_edge',
}

enum Corner {
  TopLeft = 'top_left_corner',
  TopRight = 'top_right_corner',
  BottomRight = 'bottom_right_corner',
  BottomLeft = 'bottom_left_corner',
}

interface Bounds {
  minX: number
  minY: number
  maxX: number
  maxY: number
  width: number
  height: number
  rotation?: number
}

interface RotatedBounds extends Bounds {
  rotation: number
}

interface ShapeBounds extends Bounds {
  id: string
}

interface PointSnapshot extends Bounds {
  nx: number
  nmx: number
  ny: number
  nmy: number
}

interface BoundsSnapshot extends PointSnapshot {
  nw: number
  nh: number
}

type Difference<A, B> = A extends B ? never : A

type ShapeSpecificProps<T extends Shape> = Pick<
  T,
  Difference<keyof T, keyof BaseShape>
>

type ShapeIndicatorProps<T extends Shape> = ShapeSpecificProps<T>

type ShapeUtil<K extends Shape> = {
  create(props: Partial<K>): K
  getBounds(shape: K): Bounds
  hitTest(shape: K, test: number[]): boolean
  hitTestBounds(shape: K, bounds: Bounds): boolean
  rotate(shape: K): K
  translate(shape: K, delta: number[]): K
  scale(shape: K, scale: number): K
  stretch(shape: K, scaleX: number, scaleY: number): K
  render(shape: K): JSX.Element
}

enum MoveType {
  Backward,
  Forward,
  ToFront,
  ToBack,
}

enum AlignType {
  Top,
  CenterVertical,
  Bottom,
  Left,
  CenterHorizontal,
  Right,
}

enum StretchType {
  Horizontal,
  Vertical,
}

enum DistributeType {
  Horizontal,
  Vertical,
}

interface BezierCurveSegment {
  start: number[]
  tangentStart: number[]
  normalStart: number[]
  pressureStart: number
  end: number[]
  tangentEnd: number[]
  normalEnd: number[]
  pressureEnd: number
}

/* -------------------------------------------------- */
/*                     Code Editor                    */
/* -------------------------------------------------- */

enum ControlType {
  Number = 'number',
  Vector = 'vector',
  Text = 'text',
  Select = 'select',
}

interface BaseCodeControl {
  id: string
  type: ControlType
  label: string
}

interface NumberCodeControl extends BaseCodeControl {
  type: ControlType.Number
  min?: number
  max?: number
  value: number
  step: number
  format?: (value: number) => number
}

interface VectorCodeControl extends BaseCodeControl {
  type: ControlType.Vector
  value: number[]
  isNormalized: boolean
  format?: (value: number[]) => number[]
}

interface TextCodeControl extends BaseCodeControl {
  type: ControlType.Text
  value: string
  format?: (value: string) => string
}

interface SelectCodeControl<T extends string = ''>
  extends BaseCodeControl {
  type: ControlType.Select
  value: T
  options: T[]
  format?: (string: T) => string
}

type CodeControl =
  | NumberCodeControl
  | VectorCodeControl
  | TextCodeControl
  | SelectCodeControl

type PropsOfType<T extends Record<string, unknown>> = {
  [K in keyof T]: T[K] extends boolean ? K : never
}[keyof T]

type Mutable<T extends Shape> = { -readonly [K in keyof T]: T[K] }

interface ShapeUtility<K extends Shape> {
  // A cache for the computed bounds of this kind of shape.
  boundsCache: WeakMap<K, Bounds>

  // Whether to show transform controls when this shape is selected.
  canTransform: boolean

  // Whether the shape's aspect ratio can change.
  canChangeAspectRatio: boolean

  // Whether the shape's style can be filled.
  canStyleFill: boolean

  // Whether the shape may be edited in an editing mode
  canEdit: boolean

  // Whether the shape is a foreign object.
  isForeignObject: boolean

  // Whether the shape can contain other shapes.
  isParent: boolean

  // Whether the shape is only shown when on hovered.
  isShy: boolean

  // Create a new shape.
  create(props: Partial<K>): K

  // Update a shape's styles
  applyStyles(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    style: Partial<ShapeStyles>
  ): ShapeUtility<K>

  translateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  translateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    point: number[]
  ): ShapeUtility<K>

  rotateBy(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number
  ): ShapeUtility<K>

  rotateTo(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    rotation: number,
    delta: number
  ): ShapeUtility<K>

  // Transform to fit a new bounding box when more than one shape is selected.
  transform(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  // Transform a single shape to fit a new bounding box.
  transformSingle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bounds: Bounds,
    info: {
      type: Edge | Corner
      initialShape: K
      scaleX: number
      scaleY: number
      transformOrigin: number[]
    }
  ): ShapeUtility<K>

  setProperty<P extends keyof K>(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    prop: P,
    value: K[P]
  ): ShapeUtility<K>

  // Respond when any child of this shape changes.
  onChildrenChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    children: Shape[]
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's bound elements.
  onBindingChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    bindings: Record<string, ShapeBinding>
  ): ShapeUtility<K>

  // Respond when a user moves one of the shape's handles.
  onHandleChange(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: Partial<K['handles']>
  ): ShapeUtility<K>

  onDoublePointHandle(
    this: ShapeUtility<K>,
    shape: Mutable<K>,
    handle: keyof K['handles'],
    info: PointerInfo
  ): ShapeUtility<K>

  // Respond when a user double clicks the shape's bounds.
  onBoundsReset(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Respond when a user double clicks the center of the shape.
  onDoubleFocus(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Clean up changes when a session ends.
  onSessionComplete(this: ShapeUtility<K>, shape: Mutable<K>): ShapeUtility<K>

  // Render a shape to JSX.
  render(
    this: ShapeUtility<K>,
    shape: K,
    info: {
      isEditing: boolean
      ref?: React.MutableRefObject<HTMLTextAreaElement>
    }
  ): JSX.Element

  invalidate(this: ShapeUtility<K>, shape: K): ShapeUtility<K>

  // Get the bounds of the a shape.
  getBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the routated bounds of the a shape.
  getRotatedBounds(this: ShapeUtility<K>, shape: K): Bounds

  // Get the center of the shape
  getCenter(this: ShapeUtility<K>, shape: K): number[]

  // Test whether a point lies within a shape.
  hitTest(this: ShapeUtility<K>, shape: K, test: number[]): boolean

  // Test whether bounds collide with or contain a shape.
  hitTestBounds(this: ShapeUtility<K>, shape: K, bounds: Bounds): boolean

  shouldDelete(this: ShapeUtility<K>, shape: K): boolean
}


 class CodeShape<T extends Shape> {
  private _shape: Mutable<T>
  private utils: ShapeUtility<T>

  constructor(props: T) {
    this._shape = createShape(props.type, props) as Mutable<T>
    this.utils = getShapeUtils<T>(this._shape)
    codeShapes.add(this)
  }

  export(): Mutable<T> {
    return { ...this._shape }
  }

  destroy(): void {
    codeShapes.delete(this)
  }

  moveTo(point: number[]): CodeShape<T> {
    this.utils.setProperty(this._shape, 'point', point)
    return this
  }

  translate(delta: number[]): CodeShape<T> {
    this.utils.setProperty(
      this._shape,
      'point',
      vec.add(this._shape.point, delta)
    )
    return this
  }

  rotate(rotation: number): CodeShape<T> {
    this.utils.setProperty(this._shape, 'rotation', rotation)
    return this
  }

  getBounds(): CodeShape<T> {
    this.utils.getBounds(this.shape)
    return this
  }

  hitTest(point: number[]): CodeShape<T> {
    this.utils.hitTest(this.shape, point)
    return this
  }

  get shape(): T {
    return this._shape
  }

  get point(): number[] {
    return [...this.shape.point]
  }

  get rotation(): number {
    return this.shape.rotation
  }
}

/**
 * ## Dot
 */
 class Dot extends CodeShape<DotShape> {
  constructor(props = {} as Partial<DotShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Dot,
      isGenerated: true,
      name: 'Dot',
      childIndex: 0,
      point: [0, 0],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: true,
      },
    })
  }
}

/**
 * ## Ellipse
 */
 class Ellipse extends CodeShape<EllipseShape> {
  constructor(props = {} as Partial<EllipseShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Ellipse,
      isGenerated: true,
      name: 'Ellipse',
      childIndex: 0,
      point: [0, 0],
      radiusX: 50,
      radiusY: 50,
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: { ...defaultStyle, ...props.style },
    })
  }

  get radiusX(): number {
    return this.shape.radiusX
  }

  get radiusY(): number {
    return this.shape.radiusY
  }
}

/**
 * ## Line
 */
 class Line extends CodeShape<LineShape> {
  constructor(props = {} as Partial<LineShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Line,
      isGenerated: true,
      name: 'Line',
      childIndex: 0,
      point: [0, 0],
      direction: [-0.5, 0.5],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  get direction(): number[] {
    return this.shape.direction
  }
}

/**
 * ## Polyline
 */
 class Polyline extends CodeShape<PolylineShape> {
  constructor(props = {} as Partial<PolylineShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Polyline,
      isGenerated: true,
      name: 'Polyline',
      childIndex: 0,
      point: [0, 0],
      points: [[0, 0]],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      style: defaultStyle,
      ...props,
    })
  }

  get points(): number[][] {
    return this.shape.points
  }
}

/**
 * ## Ray
 */
 class Ray extends CodeShape<RayShape> {
  constructor(props = {} as Partial<RayShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      type: ShapeType.Ray,
      isGenerated: true,
      name: 'Ray',
      parentId: 'page1',
      childIndex: 0,
      point: [0, 0],
      direction: [0, 1],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  get direction(): number[] {
    return this.shape.direction
  }
}

/**
 * ## Rectangle
 */
 class Rectangle extends CodeShape<RectangleShape> {
  constructor(props = {} as Partial<RectangleShape> & Partial<ShapeStyles>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      parentId: (window as any).currentPageId,
      type: ShapeType.Rectangle,
      isGenerated: true,
      name: 'Rectangle',
      childIndex: 0,
      point: [0, 0],
      size: [100, 100],
      rotation: 0,
      radius: 2,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: { ...defaultStyle, ...props.style },
    })
  }

  get size(): number[] {
    return this.shape.size
  }
}

/**
 * ## Draw
 */
 class Arrow extends CodeShape<ArrowShape> {
  constructor(
    props = {} as Partial<ArrowShape> &
      Partial<ShapeStyles> & { start?: number[]; end?: number[] }
  ) {
    const { start = [0, 0], end = [0, 0] } = props

    const {
      point = [0, 0],
      handles = {
        start: {
          id: 'start',
          index: 0,
          point: start,
        },
        end: {
          id: 'end',
          index: 1,
          point: end,
        },
        bend: {
          id: 'bend',
          index: 2,
          point: Vec.med(start, end),
        },
      },
    } = props

    super({
      id: uniqueId(),
      seed: Math.random(),
      type: ShapeType.Arrow,
      isGenerated: false,
      name: 'Arrow',
      parentId: 'page1',
      childIndex: 0,
      point,
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      bend: 0,
      handles,
      decorations: {
        start: null,
        middle: null,
        end: Decoration.Arrow,
      },
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
        isFilled: false,
      },
    })
  }

  get start(): number[] {
    return this.shape.handles.start.point
  }

  set start(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      start: { ...this.shape.handles.start, point },
    })
  }

  get middle(): number[] {
    return this.shape.handles.bend.point
  }

  set middle(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      bend: { ...this.shape.handles.bend, point },
    })
  }

  get end(): number[] {
    return this.shape.handles.end.point
  }

  set end(point: number[]) {
    getShapeUtils(this.shape).onHandleChange(this.shape, {
      end: { ...this.shape.handles.end, point },
    })
  }

  get bend(): number {
    return this.shape.bend
  }
}

/**
 * ## Draw
 */
 class Draw extends CodeShape<DrawShape> {
  constructor(props = {} as Partial<DrawShape>) {
    super({
      id: uniqueId(),
      seed: Math.random(),
      type: ShapeType.Draw,
      isGenerated: false,
      name: 'Draw',
      parentId: 'page1',
      childIndex: 0,
      point: [0, 0],
      points: [],
      rotation: 0,
      isAspectRatioLocked: false,
      isLocked: false,
      isHidden: false,
      ...props,
      style: {
        ...defaultStyle,
        ...props.style,
      },
    })
  }
}

/**
 * ## Utils
 */
 class Utils {
  static pointsBetween(a: number[], b: number[], steps = 6): number[][] {
    return Array.from(Array(steps))
      .map((_, i) => ease(i / steps))
      .map((t) => [...vec.lrp(a, b, t), (1 - t) / 2])
  }

  static getRayRayIntersection(
    p0: number[],
    n0: number[],
    p1: number[],
    n1: number[]
  ): number[] {
    const p0e = vec.add(p0, n0),
      p1e = vec.add(p1, n1),
      m0 = (p0e[1] - p0[1]) / (p0e[0] - p0[0]),
      m1 = (p1e[1] - p1[1]) / (p1e[0] - p1[0]),
      b0 = p0[1] - m0 * p0[0],
      b1 = p1[1] - m1 * p1[0],
      x = (b1 - b0) / (m0 - m1),
      y = m0 * x + b0

    return [x, y]
  }

  static getCircleTangentToPoint(
    A: number[],
    r0: number,
    P: number[],
    side: number
  ): number[] {
    const B = vec.lrp(A, P, 0.5),
      r1 = vec.dist(A, B),
      delta = vec.sub(B, A),
      d = vec.len(delta)

    if (!(d <= r0 + r1 && d >= Math.abs(r0 - r1))) {
      return
    }

    const a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d),
      n = 1 / d,
      p = vec.add(A, vec.mul(delta, a * n)),
      h = Math.sqrt(r0 * r0 - a * a),
      k = vec.mul(vec.per(delta), h * n)

    return side === 0 ? vec.add(p, k) : vec.sub(p, k)
  }

  static shortAngleDist(a0: number, a1: number): number {
    const max = Math.PI * 2
    const da = (a1 - a0) % max
    return ((2 * da) % max) - da
  }

  static angleDelta(a0: number, a1: number): number {
    return this.shortAngleDist(a0, a1)
  }

  static getSweep(C: number[], A: number[], B: number[]): number {
    return this.angleDelta(vec.angle(C, A), vec.angle(C, B))
  }

  static bez1d(a: number, b: number, c: number, d: number, t: number): number {
    return (
      a * (1 - t) * (1 - t) * (1 - t) +
      3 * b * t * (1 - t) * (1 - t) +
      3 * c * t * t * (1 - t) +
      d * t * t * t
    )
  }

  static getCubicBezierBounds(
    p0: number[],
    c0: number[],
    c1: number[],
    p1: number[]
  ): Bounds {
    // solve for x
    let a = 3 * p1[0] - 9 * c1[0] + 9 * c0[0] - 3 * p0[0]
    let b = 6 * p0[0] - 12 * c0[0] + 6 * c1[0]
    let c = 3 * c0[0] - 3 * p0[0]
    let disc = b * b - 4 * a * c
    let xl = p0[0]
    let xh = p0[0]

    if (p1[0] < xl) xl = p1[0]
    if (p1[0] > xh) xh = p1[0]

    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const x1 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t1)
        if (x1 < xl) xl = x1
        if (x1 > xh) xh = x1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const x2 = Utils.bez1d(p0[0], c0[0], c1[0], p1[0], t2)
        if (x2 < xl) xl = x2
        if (x2 > xh) xh = x2
      }
    }

    // Solve for y
    a = 3 * p1[1] - 9 * c1[1] + 9 * c0[1] - 3 * p0[1]
    b = 6 * p0[1] - 12 * c0[1] + 6 * c1[1]
    c = 3 * c0[1] - 3 * p0[1]
    disc = b * b - 4 * a * c
    let yl = p0[1]
    let yh = p0[1]
    if (p1[1] < yl) yl = p1[1]
    if (p1[1] > yh) yh = p1[1]
    if (disc >= 0) {
      const t1 = (-b + Math.sqrt(disc)) / (2 * a)
      if (t1 > 0 && t1 < 1) {
        const y1 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t1)
        if (y1 < yl) yl = y1
        if (y1 > yh) yh = y1
      }
      const t2 = (-b - Math.sqrt(disc)) / (2 * a)
      if (t2 > 0 && t2 < 1) {
        const y2 = Utils.bez1d(p0[1], c0[1], c1[1], p1[1], t2)
        if (y2 < yl) yl = y2
        if (y2 > yh) yh = y2
      }
    }

    return {
      minX: xl,
      minY: yl,
      maxX: xh,
      maxY: yh,
      width: Math.abs(xl - xh),
      height: Math.abs(yl - yh),
    }
  }

  static getExpandedBounds(a: Bounds, b: Bounds): Bounds {
    const minX = Math.min(a.minX, b.minX),
      minY = Math.min(a.minY, b.minY),
      maxX = Math.max(a.maxX, b.maxX),
      maxY = Math.max(a.maxY, b.maxY),
      width = Math.abs(maxX - minX),
      height = Math.abs(maxY - minY)

    return { minX, minY, maxX, maxY, width, height }
  }

  static getCommonBounds(...b: Bounds[]): Bounds {
    if (b.length < 2) return b[0]

    let bounds = b[0]

    for (let i = 1; i < b.length; i++) {
      bounds = Utils.getExpandedBounds(bounds, b[i])
    }

    return bounds
  }
}

// A big collection of vector utilities. Collected into a class to improve logging / packaging.

 class Vec {
  /**
   * Clamp a value into a range.
   * @param n
   * @param min
   */
  static clamp(n: number, min: number): number
  static clamp(n: number, min: number, max: number): number
  static clamp(n: number, min: number, max?: number): number {
    return Math.max(min, typeof max !== 'undefined' ? Math.min(n, max) : n)
  }

  /**
   * Negate a vector.
   * @param A
   */
  static neg = (A: number[]): number[] => {
    return [-A[0], -A[1]]
  }

  /**
   * Add vectors.
   * @param A
   * @param B
   */
  static add = (A: number[], B: number[]): number[] => {
    return [A[0] + B[0], A[1] + B[1]]
  }

  /**
   * Add scalar to vector.
   * @param A
   * @param B
   */
  static addScalar = (A: number[], n: number): number[] => {
    return [A[0] + n, A[1] + n]
  }

  /**
   * Subtract vectors.
   * @param A
   * @param B
   */
  static sub = (A: number[], B: number[]): number[] => {
    return [A[0] - B[0], A[1] - B[1]]
  }

  /**
   * Subtract scalar from vector.
   * @param A
   * @param B
   */
  static subScalar = (A: number[], n: number): number[] => {
    return [A[0] - n, A[1] - n]
  }

  /**
   * Get the vector from vectors A to B.
   * @param A
   * @param B
   */
  static vec = (A: number[], B: number[]): number[] => {
    // A, B as vectors get the vector from A to B
    return [B[0] - A[0], B[1] - A[1]]
  }

  /**
   * Vector multiplication by scalar
   * @param A
   * @param n
   */
  static mul = (A: number[], n: number): number[] => {
    return [A[0] * n, A[1] * n]
  }

  static mulV = (A: number[], B: number[]): number[] => {
    return [A[0] * B[0], A[1] * B[1]]
  }

  /**
   * Vector division by scalar.
   * @param A
   * @param n
   */
  static div = (A: number[], n: number): number[] => {
    return [A[0] / n, A[1] / n]
  }

  /**
   * Vector division by vector.
   * @param A
   * @param n
   */
  static divV = (A: number[], B: number[]): number[] => {
    return [A[0] / B[0], A[1] / B[1]]
  }

  /**
   * Perpendicular rotation of a vector A
   * @param A
   */
  static per = (A: number[]): number[] => {
    return [A[1], -A[0]]
  }

  /**
   * Dot product
   * @param A
   * @param B
   */
  static dpr = (A: number[], B: number[]): number => {
    return A[0] * B[0] + A[1] * B[1]
  }

  /**
   * Cross product (outer product) | A X B |
   * @param A
   * @param B
   */
  static cpr = (A: number[], B: number[]): number => {
    return A[0] * B[1] - B[0] * A[1]
  }

  /**
   * Length of the vector squared
   * @param A
   */
  static len2 = (A: number[]): number => {
    return A[0] * A[0] + A[1] * A[1]
  }

  /**
   * Length of the vector
   * @param A
   */
  static len = (A: number[]): number => {
    return Math.hypot(A[0], A[1])
  }

  /**
   * Project A over B
   * @param A
   * @param B
   */
  static pry = (A: number[], B: number[]): number => {
    return Vec.dpr(A, B) / Vec.len(B)
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static uni = (A: number[]): number[] => {
    return Vec.div(A, Vec.len(A))
  }

  /**
   * Get normalized / unit vector.
   * @param A
   */
  static normalize = (A: number[]): number[] => {
    return Vec.uni(A)
  }

  /**
   * Get the tangent between two vectors.
   * @param A
   * @param B
   * @returns
   */
  static tangent = (A: number[], B: number[]): number[] => {
    return Vec.normalize(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B squared.
   * @param A
   * @param B
   */
  static dist2 = (A: number[], B: number[]): number => {
    return Vec.len2(Vec.sub(A, B))
  }

  /**
   * Dist length from A to B
   * @param A
   * @param B
   */
  static dist = (A: number[], B: number[]): number => {
    return Math.hypot(A[1] - B[1], A[0] - B[0])
  }

  /**
   * A faster, though less accurate method for testing distances. Maybe faster?
   * @param A
   * @param B
   * @returns
   */
  static fastDist = (A: number[], B: number[]): number[] => {
    const V = [B[0] - A[0], B[1] - A[1]]
    const aV = [Math.abs(V[0]), Math.abs(V[1])]
    let r = 1 / Math.max(aV[0], aV[1])
    r = r * (1.29289 - (aV[0] + aV[1]) * r * 0.29289)
    return [V[0] * r, V[1] * r]
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static ang = (A: number[], B: number[]): number => {
    return Math.atan2(Vec.cpr(A, B), Vec.dpr(A, B))
  }

  /**
   * Angle between vector A and vector B in radians
   * @param A
   * @param B
   */
  static angle = (A: number[], B: number[]): number => {
    return Math.atan2(B[1] - A[1], B[0] - A[0])
  }

  /**
   * Mean between two vectors or mid vector between two vectors
   * @param A
   * @param B
   */
  static med = (A: number[], B: number[]): number[] => {
    return Vec.mul(Vec.add(A, B), 0.5)
  }

  /**
   * Vector rotation by r (radians)
   * @param A
   * @param r rotation in radians
   */
  static rot = (A: number[], r: number): number[] => {
    return [
      A[0] * Math.cos(r) - A[1] * Math.sin(r),
      A[0] * Math.sin(r) + A[1] * Math.cos(r),
    ]
  }

  /**
   * Rotate a vector around another vector by r (radians)
   * @param A vector
   * @param C center
   * @param r rotation in radians
   */
  static rotWith = (A: number[], C: number[], r: number): number[] => {
    if (r === 0) return A

    const s = Math.sin(r)
    const c = Math.cos(r)

    const px = A[0] - C[0]
    const py = A[1] - C[1]

    const nx = px * c - py * s
    const ny = px * s + py * c

    return [nx + C[0], ny + C[1]]
  }

  /**
   * Check of two vectors are identical.
   * @param A
   * @param B
   */
  static isEqual = (A: number[], B: number[]): boolean => {
    return A[0] === B[0] && A[1] === B[1]
  }

  /**
   * Interpolate vector A to B with a scalar t
   * @param A
   * @param B
   * @param t scalar
   */
  static lrp = (A: number[], B: number[], t: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.vec(A, B), t))
  }

  /**
   * Interpolate from A to B when curVAL goes fromVAL: number[] => to
   * @param A
   * @param B
   * @param from Starting value
   * @param to Ending value
   * @param s Strength
   */
  static int = (
    A: number[],
    B: number[],
    from: number,
    to: number,
    s = 1
  ): number[] => {
    const t = (Vec.clamp(from, to) - from) / (to - from)
    return Vec.add(Vec.mul(A, 1 - t), Vec.mul(B, s))
  }

  /**
   * Get the angle between the three vectors A, B, and C.
   * @param p1
   * @param pc
   * @param p2
   */
  static ang3 = (p1: number[], pc: number[], p2: number[]): number => {
    // this,
    const v1 = Vec.vec(pc, p1)
    const v2 = Vec.vec(pc, p2)
    return Vec.ang(v1, v2)
  }

  /**
   * Absolute value of a vector.
   * @param A
   * @returns
   */
  static abs = (A: number[]): number[] => {
    return [Math.abs(A[0]), Math.abs(A[1])]
  }

  static rescale = (a: number[], n: number): number[] => {
    const l = Vec.len(a)
    return [(n * a[0]) / l, (n * a[1]) / l]
  }

  /**
   * Get whether p1 is left of p2, relative to pc.
   * @param p1
   * @param pc
   * @param p2
   */
  static isLeft = (p1: number[], pc: number[], p2: number[]): number => {
    //  isLeft: >0 for counterclockwise
    //          =0 for none (degenerate)
    //          <0 for clockwise
    return (pc[0] - p1[0]) * (p2[1] - p1[1]) - (p2[0] - p1[0]) * (pc[1] - p1[1])
  }

  static clockwise = (p1: number[], pc: number[], p2: number[]): boolean => {
    return Vec.isLeft(p1, pc, p2) > 0
  }

  static round = (a: number[], d = 5): number[] => {
    return a.map((v) => Number(v.toPrecision(d)))
  }

  /**
   * Get the minimum distance from a point P to a line with a segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @returns
   */
  // static distanceToLine(A: number[], B: number[], P: number[]) {
  //   const delta = sub(B, A)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)
  //   return dir[1]
  // }

  /**
   * Get the nearest point on a line segment AB.
   * @param A The start of the line.
   * @param B The end of the line.
   * @param P A point.
   * @param clamp Whether to clamp the resulting point to the segment.
   * @returns
   */
  // static nearestPointOnLine(
  //   A: number[],
  //   B: number[],
  //   P: number[],
  //   clamp = true
  // ) {
  //   const delta = sub(B, A)
  //   const length = len(delta)
  //   const angle = Math.atan2(delta[1], delta[0])
  //   const dir = rot(sub(P, A), -angle)

  //   if (clamp) {
  //     if (dir[0] < 0) return A
  //     if (dir[0] > length) return B
  //   }

  //   return add(A, div(mul(delta, dir[0]), length))
  // }

  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static nearestPointOnLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number[] => {
    return Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))
  }

  /**
   * Distance between a point and a line with a known unit vector that passes through a point.
   * @param A Any point on the line
   * @param u The unit vector for the line.
   * @param P A point not on the line to test.
   * @returns
   */
  static distanceToLineThroughPoint = (
    A: number[],
    u: number[],
    P: number[]
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineThroughPoint(A, u, P))
  }

  /**
   * Get the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static nearestPointOnLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number[] => {
    const delta = Vec.sub(B, A)
    const length = Vec.len(delta)
    const u = Vec.div(delta, length)

    const pt = Vec.add(A, Vec.mul(u, Vec.pry(Vec.sub(P, A), u)))

    if (clamp) {
      const da = Vec.dist(A, pt)
      const db = Vec.dist(B, pt)

      if (db < da && da > length) return B
      if (da < db && db > length) return A
    }

    return pt
  }

  /**
   * Distance between a point and the nearest point on a line segment between A and B
   * @param A The start of the line segment
   * @param B The end of the line segment
   * @param P The off-line point
   * @param clamp Whether to clamp the point between A and B.
   * @returns
   */
  static distanceToLineSegment = (
    A: number[],
    B: number[],
    P: number[],
    clamp = true
  ): number => {
    return Vec.dist(P, Vec.nearestPointOnLineSegment(A, B, P, clamp))
  }

  /**
   * Get a vector d distance from A towards B.
   * @param A
   * @param B
   * @param d
   * @returns
   */
  static nudge = (A: number[], B: number[], d: number): number[] => {
    return Vec.add(A, Vec.mul(Vec.uni(Vec.vec(A, B)), d))
  }

  /**
   * Round a vector to a precision length.
   * @param a
   * @param n
   */
  static toPrecision = (a: number[], n = 4): number[] => {
    return [+a[0].toPrecision(n), +a[1].toPrecision(n)]
  }
}

`,
}
